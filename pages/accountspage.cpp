#include "accountspage.h"
#include <QInputDialog>
#include <QListWidgetItem>

#include <QListWidget>
#include <QPushButton>
#include <QLabel>
#include "../constants.h"

/*
                                                                Table "public.accounts"
   Column   |           Type           | Collation | Nullable |             Default              | Storage  | Compression | Stats target | Description
------------+--------------------------+-----------+----------+----------------------------------+----------+-------------+--------------+-------------
 id         | integer                  |           | not null | generated by default as identity | plain    |             |              |
 user_id    | integer                  |           | not null |                                  | plain    |             |              |
 iban       | character varying(34)    |           |          |                                  | extended |             |              |
 balance    | numeric(18,2)            |           |          | 0                                | main     |             |              |
 currency   | character(3)             |           | not null |                                  | extended |             |              |
 status     | character varying(32)    |           |          | 'active'::character varying      | extended |             |              |
 created_at | timestamp with time zone |           |          | now()                            | plain    |             |              |
 updated_at | timestamp with time zone |           |          | now()                            | plain    |             |              |

namespace Models {
struct Account
{
    qint64                   id         = 0;
    qint64                   user_id    = 0;
    std::optional<QString>   iban       = std::nullopt;
    std::optional<QString>   balance    = "0.00";
    QString                  currency;
    std::optional<QString>   status     = QStringLiteral("active");
    std::optional<QDateTime> created_at = std::nullopt;
    std::optional<QDateTime> updated_at = std::nullopt;
};
}
*/

AccountsPage::AccountsPage(AccountsService *accService, TransactionsService *trService, QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::AccountsPage)
    , m_accService(accService)
    , m_trService(trService)
{
    ui->setupUi(this);
    setupConnections();

    QMetaEnum metaEnum = QMetaEnum::fromType<Enums::Currency>();
    ui->currencyComboBox->clear();
    for (int i = 0; i < metaEnum.keyCount(); ++i) {
        QString key = metaEnum.key(i);
        Enums::Currency value = static_cast<Enums::Currency>(metaEnum.value(i));
        ui->currencyComboBox->addItem(key, QVariant::fromValue(value));
    }
}

AccountsPage::~AccountsPage() { delete ui; }

void AccountsPage::setupConnections()
{
    connect(ui->pageSpinBox, &QSpinBox::valueChanged, this,
    [this](int){
        refreshAccounts();
    });

    connect(ui->limitComboBox, &QComboBox::currentTextChanged, this,
    [this](QString){
        refreshAccounts();
    });

    connect(ui->backButton, &QPushButton::clicked, this,
    [this]{
        emit pr_dashboard();
    });

    connect(ui->refreshButton, &QPushButton::clicked, this,
    [this]{
        refreshAccounts();
    });

    connect(ui->createButton, &QPushButton::clicked, this,
    [this]{
        m_accService->createAccCreateRequest(ui->currencyComboBox->currentData().value<Enums::Currency>());
    });

    connect(ui->accountsList, &QListWidget::itemDoubleClicked, this,
    [this](QListWidgetItem *item){
        const int row = ui->accountsList->row(item);
        if (row < 0 || row >= m_accounts.size())
            return;
        const Models::Account acc = m_accounts.at(row);
        emit pr_transfer(acc);
    });

    connect(ui->testCreditButton, &QPushButton::clicked,
            this, &AccountsPage::onTestCredit);

    //Сервисы
    connect(m_accService, &AccountsService::accountsUpdated,
            this, &AccountsPage::onAccountsUpdated);
    connect(m_accService, &AccountsService::accountsFailed,
            this, &AccountsPage::onAccountsFailed);
    connect(m_accService, &AccountsService::accountCreated, this,
    [this](const Models::Account&){
        refreshAccounts();
    });
}

void AccountsPage::onTestCredit()
{
    const QListWidgetItem* current = ui->accountsList->currentItem();
    if (!current) {
        onAccountsFailed(tr("Выберите счёт перед тестовым начислением"));
        return;
    }
    const int row = ui->accountsList->row(current);
    if (row < 0 || row >= m_accounts.size()) {
        onAccountsFailed(tr("Неверный счёт"));
        return;
    }
    bool isCorrect = false;
    const QString amount = QInputDialog::getText(this,  tr("Тестовое начисление"), tr("Сумма:"), QLineEdit::Normal, "100", &isCorrect);
    if (isCorrect && !amount.isEmpty())
    {
        const Models::Account acc = m_accounts.at(row);
        const double val = amount.toDouble(&isCorrect);
        if (isCorrect && val > 0.0)
        {
            CreditData crData;
            crData.acc = acc;
            crData.amount = amount;
            m_trService->createCreditRequest(crData);
        }
        else
            onAccountsFailed(tr("Некорректная сумма для тестового начисления"));
    }
}

void AccountsPage::refreshAccounts()
{
    showLoading(tr("Загрузка счетов..."));

    int currentPage = ui->pageSpinBox->value();
    int currentLimit = ui->limitComboBox->currentText().toInt();
    qDebug() << "Page: " << currentPage << "Limit: " << currentLimit;
    m_accService->createAccListRequest(currentLimit, currentPage);
}

void AccountsPage::onAccountsUpdated(const QList<Models::Account> &accounts)
{
    ui->accountsList->clear();
    m_accounts = accounts;

    for (const auto &acc : accounts)
    {
        QString ibanStr = acc.iban.has_value() ? *acc.iban : tr("Нет IBAN");
        QString accountIds = QString("ID: %1 | %2").arg(QString::number(acc.id).leftJustified(4), ibanStr);

        Enums::Currency currEnum = Enums::fromStr(acc.currency, Enums::Currency::BYN);
        QString symbol = Enums::toSymbol(currEnum);
        if (symbol.isEmpty()) symbol = acc.currency;

        QString statusStr = acc.status.value_or("active");
        QString statusIcon = (statusStr == "active") ? "✔️" : "⚠️";

        const QString text = QString("%1 %2 %3 %4").arg(statusIcon,
                                                        accountIds.leftJustified(45, ' '),
                                                        acc.balance.value_or("0.00").rightJustified(15, ' '),
                                                        symbol);

        QListWidgetItem *item = new QListWidgetItem(text);

        if (statusStr != "active") {
            item->setForeground(Qt::gray);
            item->setToolTip(tr("Счет заморожен или неактивен"));
        }

        ui->accountsList->addItem(item);
    }

    if (accounts.isEmpty())
    {
        ui->statusLabel->setText(tr("> Аккаунты не найдены <"));
        ui->statusLabel->setProperty("state", "empty");
    }
    else
    {
        ui->statusLabel->clear();
        ui->statusLabel->setProperty("state", "");
    }
    ui->statusLabel->style()->polish(ui->statusLabel);
    ui->refreshButton->setEnabled(true);
}

void AccountsPage::onAccountsFailed(const QString &reason)
{
    ui->statusLabel->setText(tr("> Ошибка: %1 <").arg(reason.toUpper()));
    ui->statusLabel->setProperty("state", "error");
    ui->statusLabel->style()->polish(ui->statusLabel);
    ui->refreshButton->setEnabled(true);
}

void AccountsPage::showLoading(const QString &message)
{
    ui->statusLabel->setText(message.isEmpty() ? tr("> Загрузка... <") : message.toUpper());
    ui->statusLabel->setProperty("state", "loading");
    ui->statusLabel->style()->polish(ui->statusLabel);
    ui->refreshButton->setEnabled(false);
}

